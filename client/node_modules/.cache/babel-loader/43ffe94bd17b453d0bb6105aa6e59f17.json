{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = componentWithName;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _isRegex = _interopRequireDefault(require(\"is-regex\"));\n\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.find\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  var innerName = fullName;\n\n  while (/\\([^()]*\\)/g.test(innerName)) {\n    var HOC = innerName;\n    var previousHOC = void 0;\n\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n\n    innerName = innerName.replace(RegExp(\"^\".concat(HOC, \"\\\\(|\\\\)$\"), 'g'), '');\n  }\n\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName) {\n  for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n    rest[_key - 5] = arguments[_key];\n  }\n\n  if (Array.isArray(propValue)) {\n    return (0, _arrayPrototype[\"default\"])(propValue.map(function (item) {\n      return hasName.apply(void 0, [name, namesOfHOCsToStrip, item, propName, componentName].concat(rest));\n    }), Boolean) || null;\n  }\n\n  if (!_react[\"default\"].isValidElement(propValue)) {\n    return new TypeError(\"\".concat(componentName, \".\").concat(propName, \" is not a valid React element\"));\n  }\n\n  var type = propValue.type;\n  var componentNameFromType = (0, _getComponentName[\"default\"])(type);\n  var innerComponentName = namesOfHOCsToStrip.length > 0 ? stripHOCs(componentNameFromType, namesOfHOCsToStrip) : componentNameFromType;\n\n  if ((0, _isRegex[\"default\"])(name) && !name.test(innerComponentName)) {\n    return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components matching the regular expression \").concat(name));\n  }\n\n  if (!(0, _isRegex[\"default\"])(name) && innerComponentName !== name) {\n    return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components named \").concat(name, \", got \").concat(innerComponentName));\n  }\n\n  return null;\n}\n\nfunction componentWithName(name) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof name !== 'string' && !(0, _isRegex[\"default\"])(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  var passedOptions = Object.keys(options);\n\n  if (passedOptions.length > 1 || passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs') {\n    throw new TypeError(\"The only options supported are: \\u201CstripHOCs\\u201D, got: \\u201C\".concat(passedOptions.join('”, “'), \"\\u201D\"));\n  }\n\n  var _options$stripHOCs = options.stripHOCs,\n      namesOfHOCsToStrip = _options$stripHOCs === void 0 ? [] : _options$stripHOCs;\n  var allHOCNamesAreValid = namesOfHOCsToStrip.every(function (x) {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName) {\n    var propValue = props[propName];\n\n    if (props[propName] == null) {\n      return null;\n    }\n\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n\n    return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  }\n\n  componentWithNameValidator.isRequired = function componentWithNameRequired(props, propName, componentName) {\n    var propValue = props[propName];\n\n    if (propValue == null) {\n      return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` requires at least one component named \").concat(name));\n    }\n\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      rest[_key3 - 3] = arguments[_key3];\n    }\n\n    return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  };\n\n  return (0, _wrapValidator[\"default\"])(componentWithNameValidator, \"componentWithName:\".concat(name), name);\n}","map":null,"metadata":{},"sourceType":"script"}