{"ast":null,"code":"'use strict';\n\nvar ES = require('es-abstract/es2019');\n\nvar adder = function addDataProperty(key, value) {\n  var O = this; // eslint-disable-line no-invalid-this\n\n  var propertyKey = ES.ToPropertyKey(key);\n  ES.CreateDataPropertyOrThrow(O, propertyKey, value);\n};\n\nvar legacyAssign = function assign(obj, entries) {\n  for (var i = 0; i < entries.length; ++i) {\n    var entry = entries[i];\n\n    if (ES.Type(entry) !== 'Object') {\n      throw new TypeError('iterator returned a non-object; entry expected');\n    }\n\n    var key = ES.Get(entry, '0');\n    var value = ES.Get(entry, '1');\n    var propertyKey = ES.ToPropertyKey(key);\n    ES.CreateDataPropertyOrThrow(obj, propertyKey, value);\n  }\n};\n\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nmodule.exports = function fromEntries(iterable) {\n  ES.RequireObjectCoercible(iterable);\n  var obj = {}; // this part isn't in the spec, it's for a reasonable fallback for pre-ES6 environments\n\n  if (!hasSymbols) {\n    if (!ES.IsArray(iterable)) {\n      throw new TypeError('this environment lacks native Symbols, and can not support non-Array iterables');\n    }\n\n    legacyAssign(obj, iterable);\n    return obj;\n  }\n\n  return ES.AddEntriesFromIterable(obj, iterable, adder);\n};","map":null,"metadata":{},"sourceType":"script"}