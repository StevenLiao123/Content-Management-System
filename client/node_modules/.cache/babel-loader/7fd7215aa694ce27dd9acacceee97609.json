{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports['default'] = createMountWrapper;\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _airbnbPropTypes = require('airbnb-prop-types');\n\nvar _RootFinder = require('./RootFinder');\n\nvar _RootFinder2 = _interopRequireDefault(_RootFinder);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* eslint react/forbid-prop-types: 0 */\n\n\nvar stringOrFunction = _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].string]);\n\nvar makeValidElementType = function makeValidElementType(adapter) {\n  if (!adapter) {\n    return stringOrFunction;\n  }\n\n  function validElementType(props, propName) {\n    if (!adapter.isValidElementType) {\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      return stringOrFunction.apply(undefined, [props, propName].concat(args));\n    }\n\n    var propValue = props[propName];\n\n    if (propValue == null || adapter.isValidElementType(propValue)) {\n      return null;\n    }\n\n    return new TypeError(String(propName) + ' must be a valid element type!');\n  }\n\n  validElementType.isRequired = function () {\n    function validElementTypeRequired(props, propName) {\n      if (!adapter.isValidElementType) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        return stringOrFunction.isRequired.apply(stringOrFunction, [props, propName].concat(args));\n      }\n\n      var propValue = props[propName]; // eslint-disable-line react/destructuring-assignment\n\n      if (adapter.isValidElementType(propValue)) {\n        return null;\n      }\n\n      return new TypeError(String(propName) + ' must be a valid element type!');\n    }\n\n    return validElementTypeRequired;\n  }();\n\n  return validElementType;\n};\n/**\n * This is a utility component to wrap around the nodes we are\n * passing in to `mount()`. Theoretically, you could do everything\n * we are doing without this, but this makes it easier since\n * `renderIntoDocument()` doesn't really pass back a reference to\n * the DOM node it rendered to, so we can't really \"re-render\" to\n * pass new props in.\n */\n\n\nfunction createMountWrapper(node) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var adapter = options.adapter,\n      WrappingComponent = options.wrappingComponent;\n\n  var WrapperComponent = function (_React$Component) {\n    _inherits(WrapperComponent, _React$Component);\n\n    function WrapperComponent() {\n      var _ref;\n\n      _classCallCheck(this, WrapperComponent);\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var _this = _possibleConstructorReturn(this, (_ref = WrapperComponent.__proto__ || Object.getPrototypeOf(WrapperComponent)).call.apply(_ref, [this].concat(args)));\n\n      var _this$props = _this.props,\n          props = _this$props.props,\n          wrappingComponentProps = _this$props.wrappingComponentProps,\n          context = _this$props.context;\n      _this.state = {\n        mount: true,\n        props: props,\n        wrappingComponentProps: wrappingComponentProps,\n        context: context\n      };\n      return _this;\n    }\n\n    _createClass(WrapperComponent, [{\n      key: 'setChildProps',\n      value: function () {\n        function setChildProps(newProps, newContext) {\n          var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n          var _state = this.state,\n              oldProps = _state.props,\n              oldContext = _state.context;\n          var props = (0, _object2['default'])({}, oldProps, newProps);\n          var context = (0, _object2['default'])({}, oldContext, newContext);\n          this.setState({\n            props: props,\n            context: context\n          }, callback);\n        }\n\n        return setChildProps;\n      }()\n    }, {\n      key: 'setWrappingComponentProps',\n      value: function () {\n        function setWrappingComponentProps(props) {\n          var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n          this.setState({\n            wrappingComponentProps: props\n          }, callback);\n        }\n\n        return setWrappingComponentProps;\n      }()\n    }, {\n      key: 'render',\n      value: function () {\n        function render() {\n          var _props = this.props,\n              Component = _props.Component,\n              refProp = _props.refProp;\n          var _state2 = this.state,\n              mount = _state2.mount,\n              props = _state2.props,\n              wrappingComponentProps = _state2.wrappingComponentProps;\n          if (!mount) return null; // eslint-disable-next-line react/jsx-props-no-spreading\n\n          var component = _react2['default'].createElement(Component, _extends({\n            ref: refProp\n          }, props));\n\n          if (WrappingComponent) {\n            return (// eslint-disable-next-line react/jsx-props-no-spreading\n              _react2['default'].createElement(WrappingComponent, wrappingComponentProps, _react2['default'].createElement(_RootFinder2['default'], null, component))\n            );\n          }\n\n          return component;\n        }\n\n        return render;\n      }()\n    }]);\n\n    return WrapperComponent;\n  }(_react2['default'].Component);\n\n  WrapperComponent.propTypes = {\n    Component: makeValidElementType(adapter).isRequired,\n    refProp: _propTypes2['default'].oneOfType([_propTypes2['default'].string, (0, _airbnbPropTypes.ref)()]),\n    props: _propTypes2['default'].object.isRequired,\n    wrappingComponentProps: _propTypes2['default'].object,\n    context: _propTypes2['default'].object\n  };\n  WrapperComponent.defaultProps = {\n    refProp: null,\n    context: null,\n    wrappingComponentProps: null\n  };\n\n  if (options.context && (node.type.contextTypes || options.childContextTypes)) {\n    // For full rendering, we are using this wrapper component to provide context if it is\n    // specified in both the options AND the child component defines `contextTypes` statically\n    // OR the merged context types for all children (the node component or deeper children) are\n    // specified in options parameter under childContextTypes.\n    // In that case, we define both a `getChildContext()` function and a `childContextTypes` prop.\n    var childContextTypes = (0, _object2['default'])({}, node.type.contextTypes, options.childContextTypes);\n\n    WrapperComponent.prototype.getChildContext = function () {\n      function getChildContext() {\n        return this.state.context;\n      }\n\n      return getChildContext;\n    }();\n\n    WrapperComponent.childContextTypes = childContextTypes;\n  }\n\n  return WrapperComponent;\n} //# sourceMappingURL=createMountWrapper.js.map","map":null,"metadata":{},"sourceType":"script"}